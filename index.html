<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Flappy Bird - Mobile Optimized</title>
<style>
  html,body{height:100%;margin:0}
  body {
    margin: 0;
    overflow: hidden;
    background: #70c5ce;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  canvas { display:block; }
  @media (max-width:420px){ body{font-family: Arial, Helvetica, sans-serif} }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
/* -------------------------
   Flappy Bird - Fixed version
   Uses CSS-pixel coords (W/H) for game logic,
   and devicePixelRatio for crisp rendering.
   -------------------------*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// CSS-pixel viewport size (use these everywhere)
let W = window.innerWidth;
let H = window.innerHeight;
let dpr = window.devicePixelRatio || 1;

function resizeCanvas() {
  W = window.innerWidth;
  H = window.innerHeight;
  dpr = window.devicePixelRatio || 1;

  // set internal canvas pixel size
  canvas.width = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';

  // Map drawing so we draw in CSS-pixel coordinates
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // keep bird inside after resize
  bird.x = Math.max(40, W / 4);
  bird.y = Math.min(H - bird.height - 10, bird.y);
  recalcTimings();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ---------- Assets ----------
const birdImg = new Image();
birdImg.crossOrigin = 'anonymous';
birdImg.src = 'https://i.postimg.cc/9fbH08k9/image.png';

const pipeImg = new Image();
pipeImg.crossOrigin = 'anonymous';
pipeImg.src = 'https://i.postimg.cc/K8FZYMYs/image.png';

const bgImg = new Image();
bgImg.crossOrigin = 'anonymous';
bgImg.src = 'https://i.postimg.cc/x8M2ffV2/image.png';

// optional local audio (may fail if not present) - not required for game to run
const flapSound = new Audio('sounds/flap.wav');
const hitSound = new Audio('sounds/hit.wav');
flapSound.preload = 'auto';
hitSound.preload = 'auto';

let audioEnabled = false;
function enableAudio() {
  if (audioEnabled) return;
  audioEnabled = true;
  // try to unlock by attempting play (catch errors)
  flapSound.play().catch(()=>{});
}

// ---------- Game state ----------
let bird = {
  x: W / 4,
  y: H / 2,
  width: Math.max(36, Math.round(W * 0.08)),
  height: Math.max(26, Math.round(H * 0.06)),
  gravity: 0.45,
  lift: -9,
  velocity: 0
};

let pipes = [];
let lastPipeTime = 0;
let pipeInterval = 1200;
let score = 0;
let speed = 2.0;
let gameOverFlag = false;
let gameStarted = false;
let startButton = null;
let lastFrameTime = performance.now();

function recalcTimings() {
  // recalc sizes according to current W/H
  bird.width = Math.max(36, Math.round(W * 0.08));
  bird.height = Math.max(26, Math.round(H * 0.06));
  pipeInterval = Math.max(700, Math.round(1200 * (H / 800)));
}

// ---------- Helpers ----------
function mapEventToCanvas(clientX, clientY) {
  // Use bounding rect to convert to CSS pixels (W/H space)
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  return { x, y };
}

// ---------- Pipes ----------
function createPipe() {
  const gap = Math.max(H * 0.28, 120);
  const pipeWidth = Math.max(60, Math.round(W * 0.12));
  const top = Math.random() * (H * 0.45);
  const bottom = Math.max(60, H - top - gap);
  pipes.push({ x: W, top, bottom, width: pipeWidth, scored: false });
}

// ---------- Drawing ----------
function drawBackground() {
  if (bgImg.complete && bgImg.naturalWidth !== 0) {
    ctx.drawImage(bgImg, 0, 0, W, H);
  } else {
    ctx.fillStyle = '#70c5ce';
    ctx.fillRect(0, 0, W, H);
  }
}

function drawBird() {
  ctx.save();
  ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
  let angle = Math.min(Math.max(bird.velocity / 20, -0.6), 0.6);
  ctx.rotate(angle);
  if (birdImg.complete && birdImg.naturalWidth !== 0) {
    ctx.drawImage(birdImg, -bird.width / 2, -bird.height / 2, bird.width, bird.height);
  } else {
    ctx.fillStyle = 'yellow';
    ctx.fillRect(-bird.width/2, -bird.height/2, bird.width, bird.height);
  }
  ctx.restore();
}

function drawPipes() {
  for (let pipe of pipes) {
    if (pipeImg.complete && pipeImg.naturalWidth !== 0) {
      // draw top (we simply stretch the image)
      ctx.drawImage(pipeImg, pipe.x, 0, pipe.width, pipe.top);
      // draw bottom
      ctx.drawImage(pipeImg, pipe.x, H - pipe.bottom, pipe.width, pipe.bottom);
    } else {
      ctx.fillStyle = 'green';
      ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
      ctx.fillRect(pipe.x, H - pipe.bottom, pipe.width, pipe.bottom);
    }
  }
}

function drawScore() {
  ctx.fillStyle = 'white';
  ctx.font = `${Math.max(14, Math.round(W / 20))}px Arial`;
  ctx.textAlign = 'left';
  ctx.fillText("Score: " + score, 20, 40);
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

function drawButton() {
  const btnWidth = Math.round(Math.min(260, W * 0.5));
  const btnHeight = Math.round(Math.min(80, H * 0.09));
  const x = Math.round((W - btnWidth) / 2);
  const y = Math.round(H / 2 + H * 0.06);

  ctx.fillStyle = '#ffcc00';
  roundRect(ctx, x, y, btnWidth, btnHeight, 12, true, false);
  ctx.fillStyle = 'black';
  ctx.font = `${Math.max(14, Math.round(btnHeight * 0.45))}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText("Start Game", x + btnWidth/2, y + btnHeight/2);

  startButton = { x, y, width: btnWidth, height: btnHeight };
}

function drawStartScreen() {
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'white';
  ctx.font = `${Math.max(24, Math.round(W / 10))}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText("Flappy Bird", W / 2, H / 2 - 120);
  ctx.font = `${Math.max(12, Math.round(W / 25))}px Arial`;
  ctx.fillText("Tap or Press SPACE to Start", W / 2, H / 2 - 60);
  drawButton();
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'white';
  ctx.font = `${Math.max(24, Math.round(W / 10))}px Arial`;
  ctx.textAlign = 'center';
  ctx.fillText("Game Over", W / 2, H / 2 - 20);
  ctx.font = `${Math.max(14, Math.round(W / 20))}px Arial`;
  ctx.fillText("Score: " + score, W / 2, H / 2 + 40);
  ctx.font = `${Math.max(12, Math.round(W / 25))}px Arial`;
  ctx.fillText("Tap or Press SPACE to Restart", W / 2, H / 2 + 100);
}

// ---------- Game logic ----------
function update(delta) {
  if (!gameStarted || gameOverFlag) return;

  const dt = delta / 16.666; // normalize to ~60fps
  bird.velocity += bird.gravity * dt;
  bird.y += bird.velocity * dt;

  const now = performance.now();
  if (now - lastPipeTime > pipeInterval) {
    createPipe();
    lastPipeTime = now;
  }

  for (let pipe of pipes) {
    pipe.x -= speed * dt;

    if (
      bird.x + bird.width > pipe.x &&
      bird.x < pipe.x + pipe.width &&
      (bird.y < pipe.top || bird.y + bird.height > H - pipe.bottom)
    ) {
      if (!gameOverFlag) {
        hitSound.play?.().catch?.(()=>{});
      }
      gameOverFlag = true;
    }

    if (!pipe.scored && pipe.x + pipe.width < bird.x) {
      score++;
      pipe.scored = true;
      if (score % 5 === 0) speed += 0.25;
    }
  }

  // remove off-screen pipes
  pipes = pipes.filter(p => p.x + p.width > -50);

  if (bird.y + bird.height > H || bird.y < -30) {
    hitSound.play?.().catch?.(()=>{});
    gameOverFlag = true;
  }
}

function draw() {
  drawBackground();
  drawPipes();
  drawBird();
  drawScore();
  if (!gameStarted) drawStartScreen();
  if (gameOverFlag) drawGameOver();
}

function loop(now) {
  const delta = now - lastFrameTime;
  lastFrameTime = now;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}

// ---------- Controls ----------
function flap() {
  if (!gameStarted || gameOverFlag) return;
  bird.velocity = bird.lift;
  if (audioEnabled) { try { flapSound.currentTime = 0; flapSound.play().catch(()=>{}); } catch(e){} }
}

function resetGame() {
  bird.y = H / 2;
  bird.velocity = 0;
  pipes = [];
  score = 0;
  speed = 2.0;
  lastPipeTime = performance.now();
  gameOverFlag = false;
}

function startGame() {
  gameStarted = true;
  resetGame();
}

// events
canvas.addEventListener('click', (e) => {
  const p = mapEventToCanvas(e.clientX, e.clientY);
  if (!gameStarted && startButton &&
      p.x >= startButton.x && p.x <= startButton.x + startButton.width &&
      p.y >= startButton.y && p.y <= startButton.y + startButton.height) {
    startGame();
  } else if (gameOverFlag) {
    resetGame();
  } else {
    if (!gameStarted) startGame();
    else flap();
  }
});

canvas.addEventListener('touchstart', (e) => {
  if (e.cancelable) e.preventDefault();
  enableAudio();
  const touch = e.touches[0];
  const p = mapEventToCanvas(touch.clientX, touch.clientY);
  if (!gameStarted && startButton &&
      p.x >= startButton.x && p.x <= startButton.x + startButton.width &&
      p.y >= startButton.y && p.y <= startButton.y + startButton.height) {
    startGame();
  } else if (gameOverFlag) {
    resetGame();
  } else {
    if (!gameStarted) startGame();
    else flap();
  }
}, { passive: false });

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    enableAudio();
    e.preventDefault();
    if (!gameStarted) startGame();
    else if (gameOverFlag) resetGame();
    else flap();
  }
});

// ---------- Asset loading ----------
let assetsLoaded = 0;
const totalAssets = 3;
function assetLoaded(){
  assetsLoaded++;
  if (assetsLoaded === totalAssets) {
    lastFrameTime = performance.now();
    requestAnimationFrame(loop);
  }
}
birdImg.onload = assetLoaded;
pipeImg.onload = assetLoaded;
bgImg.onload = assetLoaded;
// if cached
if (birdImg.complete && pipeImg.complete && bgImg.complete && assetsLoaded < totalAssets) {
  assetsLoaded = totalAssets;
  lastFrameTime = performance.now();
  requestAnimationFrame(loop);
}

// make sure initial values set
recalcTimings();
lastPipeTime = performance.now();

</script>
</body>
</html>
